// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWebhookDeliveries = `-- name: CountWebhookDeliveries :one
SELECT count(*)
FROM webhook_deliveries wd
WHERE ($1::uuid IS NULL OR wd.endpoint_id = $1::uuid)
  AND ($2::uuid IS NULL OR wd.event_id = $2::uuid)
  AND ($3::text IS NULL OR $3::text = '' OR wd.status = $3::delivery_status)
`

type CountWebhookDeliveriesParams struct {
	EndpointID pgtype.UUID `json:"endpoint_id"`
	EventID    pgtype.UUID `json:"event_id"`
	Status     string      `json:"status"`
}

func (q *Queries) CountWebhookDeliveries(ctx context.Context, arg CountWebhookDeliveriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhookDeliveries, arg.EndpointID, arg.EventID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhookEndpoint = `-- name: CreateWebhookEndpoint :one
INSERT INTO webhook_endpoints (name, url, secret, active, topics)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, url, secret, active, topics, created_at, updated_at
`

type CreateWebhookEndpointParams struct {
	Name   string   `json:"name"`
	Url    string   `json:"url"`
	Secret string   `json:"secret"`
	Active bool     `json:"active"`
	Topics []string `json:"topics"`
}

func (q *Queries) CreateWebhookEndpoint(ctx context.Context, arg CreateWebhookEndpointParams) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, createWebhookEndpoint,
		arg.Name,
		arg.Url,
		arg.Secret,
		arg.Active,
		arg.Topics,
	)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Active,
		&i.Topics,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDlqByDelivery = `-- name: DeleteDlqByDelivery :exec
DELETE FROM webhook_dlq
WHERE delivery_id = $1
`

func (q *Queries) DeleteDlqByDelivery(ctx context.Context, deliveryID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDlqByDelivery, deliveryID)
	return err
}

const deleteWebhookEndpoint = `-- name: DeleteWebhookEndpoint :exec
DELETE FROM webhook_endpoints
WHERE id = $1
`

func (q *Queries) DeleteWebhookEndpoint(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhookEndpoint, id)
	return err
}

const dequeueDueDeliveries = `-- name: DequeueDueDeliveries :many
SELECT id, endpoint_id, event_id, status, attempt, max_attempt, next_attempt_at, last_error, response_status, response_body, created_at, updated_at
FROM webhook_deliveries
WHERE status IN ('PENDING', 'FAILED')
  AND (next_attempt_at IS NULL OR next_attempt_at <= now())
ORDER BY next_attempt_at NULLS FIRST, created_at ASC
LIMIT $1
`

func (q *Queries) DequeueDueDeliveries(ctx context.Context, limit int32) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, dequeueDueDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDelivery
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.EventID,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempt,
			&i.NextAttemptAt,
			&i.LastError,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueueDelivery = `-- name: EnqueueDelivery :one
INSERT INTO webhook_deliveries (endpoint_id, event_id, status, max_attempt, next_attempt_at)
VALUES ($1, $2, 'PENDING', $3, now())
RETURNING id, endpoint_id, event_id, status, attempt, max_attempt, next_attempt_at, last_error, response_status, response_body, created_at, updated_at
`

type EnqueueDeliveryParams struct {
	EndpointID pgtype.UUID `json:"endpoint_id"`
	EventID    pgtype.UUID `json:"event_id"`
	MaxAttempt int32       `json:"max_attempt"`
}

func (q *Queries) EnqueueDelivery(ctx context.Context, arg EnqueueDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, enqueueDelivery, arg.EndpointID, arg.EventID, arg.MaxAttempt)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.EventID,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempt,
		&i.NextAttemptAt,
		&i.LastError,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryByID = `-- name: GetDeliveryByID :one
SELECT id, endpoint_id, event_id, status, attempt, max_attempt, next_attempt_at, last_error, response_status, response_body, created_at, updated_at
FROM webhook_deliveries
WHERE id = $1
`

func (q *Queries) GetDeliveryByID(ctx context.Context, id pgtype.UUID) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, getDeliveryByID, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.EventID,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempt,
		&i.NextAttemptAt,
		&i.LastError,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookEndpoint = `-- name: GetWebhookEndpoint :one
SELECT id, name, url, secret, active, topics, created_at, updated_at
FROM webhook_endpoints
WHERE id = $1
`

func (q *Queries) GetWebhookEndpoint(ctx context.Context, id pgtype.UUID) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, getWebhookEndpoint, id)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Active,
		&i.Topics,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertWebhookDlq = `-- name: InsertWebhookDlq :one
INSERT INTO webhook_dlq (delivery_id, reason)
VALUES ($1, $2)
RETURNING id, delivery_id, reason, created_at
`

type InsertWebhookDlqParams struct {
	DeliveryID pgtype.UUID `json:"delivery_id"`
	Reason     pgtype.Text `json:"reason"`
}

func (q *Queries) InsertWebhookDlq(ctx context.Context, arg InsertWebhookDlqParams) (WebhookDlq, error) {
	row := q.db.QueryRow(ctx, insertWebhookDlq, arg.DeliveryID, arg.Reason)
	var i WebhookDlq
	err := row.Scan(
		&i.ID,
		&i.DeliveryID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveEndpointsForTopic = `-- name: ListActiveEndpointsForTopic :many
SELECT id, name, url, secret, active, topics, created_at, updated_at
FROM webhook_endpoints
WHERE active = true
  AND (coalesce(array_length(topics, 1), 0) = 0 OR $1::text = ANY(topics))
ORDER BY created_at ASC
`

func (q *Queries) ListActiveEndpointsForTopic(ctx context.Context, topic string) ([]WebhookEndpoint, error) {
	rows, err := q.db.Query(ctx, listActiveEndpointsForTopic, topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookEndpoint
	for rows.Next() {
		var i WebhookEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Active,
			&i.Topics,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDeliveries = `-- name: ListWebhookDeliveries :many
SELECT wd.id, wd.endpoint_id, wd.event_id, wd.status, wd.attempt, wd.max_attempt, wd.next_attempt_at, wd.last_error, wd.response_status, wd.response_body, wd.created_at, wd.updated_at, we.name AS endpoint_name, we.url AS endpoint_url, we.active AS endpoint_active
FROM webhook_deliveries wd
JOIN webhook_endpoints we ON we.id = wd.endpoint_id
WHERE ($1::uuid IS NULL OR wd.endpoint_id = $1::uuid)
  AND ($2::uuid IS NULL OR wd.event_id = $2::uuid)
  AND ($3::text IS NULL OR $3::text = '' OR wd.status = $3::delivery_status)
ORDER BY wd.created_at DESC
LIMIT $5 OFFSET $4
`

type ListWebhookDeliveriesParams struct {
	EndpointID pgtype.UUID `json:"endpoint_id"`
	EventID    pgtype.UUID `json:"event_id"`
	Status     string      `json:"status"`
	PageOffset int32       `json:"page_offset"`
	PageLimit  int32       `json:"page_limit"`
}

type ListWebhookDeliveriesRow struct {
	ID             pgtype.UUID        `json:"id"`
	EndpointID     pgtype.UUID        `json:"endpoint_id"`
	EventID        pgtype.UUID        `json:"event_id"`
	Status         DeliveryStatus     `json:"status"`
	Attempt        int32              `json:"attempt"`
	MaxAttempt     int32              `json:"max_attempt"`
	NextAttemptAt  pgtype.Timestamptz `json:"next_attempt_at"`
	LastError      pgtype.Text        `json:"last_error"`
	ResponseStatus pgtype.Int4        `json:"response_status"`
	ResponseBody   pgtype.Text        `json:"response_body"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	EndpointName   string             `json:"endpoint_name"`
	EndpointUrl    string             `json:"endpoint_url"`
	EndpointActive bool               `json:"endpoint_active"`
}

func (q *Queries) ListWebhookDeliveries(ctx context.Context, arg ListWebhookDeliveriesParams) ([]ListWebhookDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, listWebhookDeliveries,
		arg.EndpointID,
		arg.EventID,
		arg.Status,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWebhookDeliveriesRow
	for rows.Next() {
		var i ListWebhookDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.EventID,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempt,
			&i.NextAttemptAt,
			&i.LastError,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointName,
			&i.EndpointUrl,
			&i.EndpointActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookEndpoints = `-- name: ListWebhookEndpoints :many
SELECT id, name, url, secret, active, topics, created_at, updated_at
FROM webhook_endpoints
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListWebhookEndpointsParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

func (q *Queries) ListWebhookEndpoints(ctx context.Context, arg ListWebhookEndpointsParams) ([]WebhookEndpoint, error) {
	rows, err := q.db.Query(ctx, listWebhookEndpoints, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookEndpoint
	for rows.Next() {
		var i WebhookEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Active,
			&i.Topics,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDelivered = `-- name: MarkDelivered :exec
UPDATE webhook_deliveries
SET status = 'DELIVERED',
    response_status = $1,
    response_body = $2,
    last_error = NULL,
    next_attempt_at = NULL,
    updated_at = now()
WHERE id = $3
`

type MarkDeliveredParams struct {
	ResponseStatus pgtype.Int4 `json:"response_status"`
	ResponseBody   pgtype.Text `json:"response_body"`
	ID             pgtype.UUID `json:"id"`
}

func (q *Queries) MarkDelivered(ctx context.Context, arg MarkDeliveredParams) error {
	_, err := q.db.Exec(ctx, markDelivered, arg.ResponseStatus, arg.ResponseBody, arg.ID)
	return err
}

const markDelivering = `-- name: MarkDelivering :exec
UPDATE webhook_deliveries
SET status = 'DELIVERING', updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkDelivering(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDelivering, id)
	return err
}

const markFailedWithBackoff = `-- name: MarkFailedWithBackoff :exec
UPDATE webhook_deliveries
SET status = 'FAILED',
    attempt = attempt + 1,
    next_attempt_at = now() + ($1::int * interval '1 second'),
    last_error = $2,
    updated_at = now()
WHERE id = $3
`

type MarkFailedWithBackoffParams struct {
	DelaySec  int32       `json:"delay_sec"`
	LastError pgtype.Text `json:"last_error"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) MarkFailedWithBackoff(ctx context.Context, arg MarkFailedWithBackoffParams) error {
	_, err := q.db.Exec(ctx, markFailedWithBackoff, arg.DelaySec, arg.LastError, arg.ID)
	return err
}

const moveToDLQ = `-- name: MoveToDLQ :exec
UPDATE webhook_deliveries
SET status = 'DLQ',
    last_error = $1,
    next_attempt_at = NULL,
    updated_at = now()
WHERE id = $2
`

type MoveToDLQParams struct {
	LastError pgtype.Text `json:"last_error"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) MoveToDLQ(ctx context.Context, arg MoveToDLQParams) error {
	_, err := q.db.Exec(ctx, moveToDLQ, arg.LastError, arg.ID)
	return err
}

const resetDeliveryForReplay = `-- name: ResetDeliveryForReplay :one
UPDATE webhook_deliveries
SET status = 'PENDING',
    attempt = 0,
    next_attempt_at = now(),
    last_error = NULL,
    response_status = NULL,
    response_body = NULL,
    updated_at = now()
WHERE id = $1
RETURNING id, endpoint_id, event_id, status, attempt, max_attempt, next_attempt_at, last_error, response_status, response_body, created_at, updated_at
`

func (q *Queries) ResetDeliveryForReplay(ctx context.Context, id pgtype.UUID) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, resetDeliveryForReplay, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.EventID,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempt,
		&i.NextAttemptAt,
		&i.LastError,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWebhookEndpoint = `-- name: UpdateWebhookEndpoint :one
UPDATE webhook_endpoints
SET name = $1,
    url = $2,
    secret = $3,
    active = $4,
    topics = $5,
    updated_at = now()
WHERE id = $6
RETURNING id, name, url, secret, active, topics, created_at, updated_at
`

type UpdateWebhookEndpointParams struct {
	Name   string      `json:"name"`
	Url    string      `json:"url"`
	Secret string      `json:"secret"`
	Active bool        `json:"active"`
	Topics []string    `json:"topics"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateWebhookEndpoint(ctx context.Context, arg UpdateWebhookEndpointParams) (WebhookEndpoint, error) {
	row := q.db.QueryRow(ctx, updateWebhookEndpoint,
		arg.Name,
		arg.Url,
		arg.Secret,
		arg.Active,
		arg.Topics,
		arg.ID,
	)
	var i WebhookEndpoint
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Active,
		&i.Topics,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
