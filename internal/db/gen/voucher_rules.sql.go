// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: voucher_rules.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVoucherUsageByUser = `-- name: CountVoucherUsageByUser :one
SELECT COUNT(*)
FROM voucher_usages
WHERE voucher_id = $1
  AND user_id = $2
`

type CountVoucherUsageByUserParams struct {
	VoucherID pgtype.UUID `json:"voucher_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) CountVoucherUsageByUser(ctx context.Context, arg CountVoucherUsageByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVoucherUsageByUser, arg.VoucherID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVoucher = `-- name: CreateVoucher :one
INSERT INTO vouchers (code, value, kind, percent_bps, min_spend, usage_limit, valid_from, valid_to, product_ids, category_ids, brand_ids, combinable, priority, per_user_limit)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, code, value, min_spend, usage_limit, used_count, valid_from, valid_to, product_ids, category_ids, created_at, updated_at, kind, percent_bps, combinable, priority, per_user_limit, brand_ids
`

type CreateVoucherParams struct {
	Code         string             `json:"code"`
	Value        int64              `json:"value"`
	Kind         DiscountKind       `json:"kind"`
	PercentBps   pgtype.Int4        `json:"percent_bps"`
	MinSpend     int64              `json:"min_spend"`
	UsageLimit   pgtype.Int4        `json:"usage_limit"`
	ValidFrom    pgtype.Timestamptz `json:"valid_from"`
	ValidTo      pgtype.Timestamptz `json:"valid_to"`
	ProductIds   []pgtype.UUID      `json:"product_ids"`
	CategoryIds  []pgtype.UUID      `json:"category_ids"`
	BrandIds     []pgtype.UUID      `json:"brand_ids"`
	Combinable   bool               `json:"combinable"`
	Priority     int32              `json:"priority"`
	PerUserLimit pgtype.Int4        `json:"per_user_limit"`
}

func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, createVoucher,
		arg.Code,
		arg.Value,
		arg.Kind,
		arg.PercentBps,
		arg.MinSpend,
		arg.UsageLimit,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ProductIds,
		arg.CategoryIds,
		arg.BrandIds,
		arg.Combinable,
		arg.Priority,
		arg.PerUserLimit,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.ValidFrom,
		&i.ValidTo,
		&i.ProductIds,
		&i.CategoryIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Kind,
		&i.PercentBps,
		&i.Combinable,
		&i.Priority,
		&i.PerUserLimit,
		&i.BrandIds,
	)
	return i, err
}

const getVoucherByCodeForUpdate = `-- name: GetVoucherByCodeForUpdate :one
SELECT id, code, value, min_spend, usage_limit, used_count, valid_from, valid_to, product_ids, category_ids, created_at, updated_at, kind, percent_bps, combinable, priority, per_user_limit, brand_ids
FROM vouchers
WHERE code = $1
FOR UPDATE
`

func (q *Queries) GetVoucherByCodeForUpdate(ctx context.Context, code string) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherByCodeForUpdate, code)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.ValidFrom,
		&i.ValidTo,
		&i.ProductIds,
		&i.CategoryIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Kind,
		&i.PercentBps,
		&i.Combinable,
		&i.Priority,
		&i.PerUserLimit,
		&i.BrandIds,
	)
	return i, err
}

const getVoucherUsageByOrder = `-- name: GetVoucherUsageByOrder :one
SELECT id, voucher_id, user_id, order_id, used_at, amount
FROM voucher_usages
WHERE voucher_id = $1
  AND order_id = $2
LIMIT 1
`

type GetVoucherUsageByOrderParams struct {
	VoucherID pgtype.UUID `json:"voucher_id"`
	OrderID   pgtype.UUID `json:"order_id"`
}

func (q *Queries) GetVoucherUsageByOrder(ctx context.Context, arg GetVoucherUsageByOrderParams) (VoucherUsage, error) {
	row := q.db.QueryRow(ctx, getVoucherUsageByOrder, arg.VoucherID, arg.OrderID)
	var i VoucherUsage
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.OrderID,
		&i.UsedAt,
		&i.Amount,
	)
	return i, err
}

const insertVoucherUsage = `-- name: InsertVoucherUsage :exec
INSERT INTO voucher_usages (voucher_id, user_id, order_id, amount)
VALUES ($1, $2, $3, $4)
ON CONFLICT (voucher_id, order_id) DO NOTHING
`

type InsertVoucherUsageParams struct {
	VoucherID pgtype.UUID `json:"voucher_id"`
	UserID    pgtype.UUID `json:"user_id"`
	OrderID   pgtype.UUID `json:"order_id"`
	Amount    int64       `json:"amount"`
}

func (q *Queries) InsertVoucherUsage(ctx context.Context, arg InsertVoucherUsageParams) error {
	_, err := q.db.Exec(ctx, insertVoucherUsage,
		arg.VoucherID,
		arg.UserID,
		arg.OrderID,
		arg.Amount,
	)
	return err
}

const updateVoucher = `-- name: UpdateVoucher :one
UPDATE vouchers
SET value = $2,
    kind = $3,
    percent_bps = $4,
    min_spend = $5,
    usage_limit = $6,
    valid_from = $7,
    valid_to = $8,
    product_ids = $9,
    category_ids = $10,
    brand_ids = $11,
    combinable = $12,
    priority = $13,
    per_user_limit = $14,
    updated_at = now()
WHERE code = $1
RETURNING id, code, value, min_spend, usage_limit, used_count, valid_from, valid_to, product_ids, category_ids, created_at, updated_at, kind, percent_bps, combinable, priority, per_user_limit, brand_ids
`

type UpdateVoucherParams struct {
	Code         string             `json:"code"`
	Value        int64              `json:"value"`
	Kind         DiscountKind       `json:"kind"`
	PercentBps   pgtype.Int4        `json:"percent_bps"`
	MinSpend     int64              `json:"min_spend"`
	UsageLimit   pgtype.Int4        `json:"usage_limit"`
	ValidFrom    pgtype.Timestamptz `json:"valid_from"`
	ValidTo      pgtype.Timestamptz `json:"valid_to"`
	ProductIds   []pgtype.UUID      `json:"product_ids"`
	CategoryIds  []pgtype.UUID      `json:"category_ids"`
	BrandIds     []pgtype.UUID      `json:"brand_ids"`
	Combinable   bool               `json:"combinable"`
	Priority     int32              `json:"priority"`
	PerUserLimit pgtype.Int4        `json:"per_user_limit"`
}

func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, updateVoucher,
		arg.Code,
		arg.Value,
		arg.Kind,
		arg.PercentBps,
		arg.MinSpend,
		arg.UsageLimit,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ProductIds,
		arg.CategoryIds,
		arg.BrandIds,
		arg.Combinable,
		arg.Priority,
		arg.PerUserLimit,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.ValidFrom,
		&i.ValidTo,
		&i.ProductIds,
		&i.CategoryIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Kind,
		&i.PercentBps,
		&i.Combinable,
		&i.Priority,
		&i.PerUserLimit,
		&i.BrandIds,
	)
	return i, err
}
