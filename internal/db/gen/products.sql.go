// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProductsPublic = `-- name: CountProductsPublic :one
SELECT COUNT(*)
FROM products p
LEFT JOIN brands b ON b.id = p.brand_id
LEFT JOIN categories c ON c.id = p.category_id
WHERE ($1::text IS NULL OR p.title ILIKE '%%' || $1 || '%%')
  AND ($2::text IS NULL OR c.slug = $2)
  AND ($3::text IS NULL OR b.slug = $3)
  AND ($4::bigint IS NULL OR p.price >= $4)
  AND ($5::bigint IS NULL OR p.price <= $5)
  AND ($6::boolean IS NULL OR p.in_stock = $6)
`

type CountProductsPublicParams struct {
	Q            pgtype.Text `json:"q"`
	CategorySlug pgtype.Text `json:"category_slug"`
	BrandSlug    pgtype.Text `json:"brand_slug"`
	MinPrice     pgtype.Int8 `json:"min_price"`
	MaxPrice     pgtype.Int8 `json:"max_price"`
	InStock      pgtype.Bool `json:"in_stock"`
}

func (q *Queries) CountProductsPublic(ctx context.Context, arg CountProductsPublicParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsPublic,
		arg.Q,
		arg.CategorySlug,
		arg.BrandSlug,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStock,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id,
       title,
       slug,
       price,
       compare_at,
       in_stock,
       thumbnail,
       badges,
       brand_id,
       category_id,
       created_at,
       COALESCE((SELECT SUM(stock) FROM product_variants WHERE product_id = products.id), 0)::int AS total_stock
FROM products
WHERE slug = $1
LIMIT 1
`

type GetProductBySlugRow struct {
	ID         pgtype.UUID        `json:"id"`
	Title      string             `json:"title"`
	Slug       string             `json:"slug"`
	Price      int64              `json:"price"`
	CompareAt  pgtype.Int8        `json:"compare_at"`
	InStock    bool               `json:"in_stock"`
	Thumbnail  pgtype.Text        `json:"thumbnail"`
	Badges     []string           `json:"badges"`
	BrandID    pgtype.UUID        `json:"brand_id"`
	CategoryID pgtype.UUID        `json:"category_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	TotalStock int32              `json:"total_stock"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Price,
		&i.CompareAt,
		&i.InStock,
		&i.Thumbnail,
		&i.Badges,
		&i.BrandID,
		&i.CategoryID,
		&i.CreatedAt,
		&i.TotalStock,
	)
	return i, err
}

const getProductForCart = `-- name: GetProductForCart :one
SELECT id,
       title,
       slug,
       price,
       category_id,
       brand_id
FROM products
WHERE id = $1
LIMIT 1
`

type GetProductForCartRow struct {
	ID         pgtype.UUID `json:"id"`
	Title      string      `json:"title"`
	Slug       string      `json:"slug"`
	Price      int64       `json:"price"`
	CategoryID pgtype.UUID `json:"category_id"`
	BrandID    pgtype.UUID `json:"brand_id"`
}

func (q *Queries) GetProductForCart(ctx context.Context, id pgtype.UUID) (GetProductForCartRow, error) {
	row := q.db.QueryRow(ctx, getProductForCart, id)
	var i GetProductForCartRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Price,
		&i.CategoryID,
		&i.BrandID,
	)
	return i, err
}

const getVariantForCart = `-- name: GetVariantForCart :one
SELECT id,
       product_id,
       price,
       stock
FROM product_variants
WHERE id = $1
LIMIT 1
`

type GetVariantForCartRow struct {
	ID        pgtype.UUID `json:"id"`
	ProductID pgtype.UUID `json:"product_id"`
	Price     int64       `json:"price"`
	Stock     int32       `json:"stock"`
}

func (q *Queries) GetVariantForCart(ctx context.Context, id pgtype.UUID) (GetVariantForCartRow, error) {
	row := q.db.QueryRow(ctx, getVariantForCart, id)
	var i GetVariantForCartRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Price,
		&i.Stock,
	)
	return i, err
}

const listImagesByProduct = `-- name: ListImagesByProduct :many
SELECT id,
       product_id,
       url,
       sort_order
FROM product_images
WHERE product_id = $1
ORDER BY sort_order ASC, id
`

func (q *Queries) ListImagesByProduct(ctx context.Context, productID pgtype.UUID) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, listImagesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Url,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsPublic = `-- name: ListProductsPublic :many
SELECT p.id,
       p.title,
       p.slug,
       p.price,
       p.compare_at,
       p.in_stock,
       p.thumbnail,
       p.badges,
       p.created_at,
       COALESCE((SELECT SUM(stock) FROM product_variants WHERE product_id = p.id), 0)::int AS total_stock
FROM products p
LEFT JOIN brands b ON b.id = p.brand_id
LEFT JOIN categories c ON c.id = p.category_id
WHERE ($1::text IS NULL OR p.title ILIKE '%%' || $1 || '%%')
  AND ($2::text IS NULL OR c.slug = $2)
  AND ($3::text IS NULL OR b.slug = $3)
  AND ($4::bigint IS NULL OR p.price >= $4)
  AND ($5::bigint IS NULL OR p.price <= $5)
  AND ($6::boolean IS NULL OR p.in_stock = $6)
ORDER BY CASE WHEN $7::text = 'price:asc' THEN p.price END ASC,
         CASE WHEN $7::text = 'price:desc' THEN p.price END DESC,
         CASE WHEN $7::text = 'title:asc' THEN p.title END ASC,
         CASE WHEN $7::text = 'title:desc' THEN p.title END DESC,
         p.created_at DESC
LIMIT $9 OFFSET $8
`

type ListProductsPublicParams struct {
	Q            pgtype.Text `json:"q"`
	CategorySlug pgtype.Text `json:"category_slug"`
	BrandSlug    pgtype.Text `json:"brand_slug"`
	MinPrice     pgtype.Int8 `json:"min_price"`
	MaxPrice     pgtype.Int8 `json:"max_price"`
	InStock      pgtype.Bool `json:"in_stock"`
	Sort         string      `json:"sort"`
	OffsetValue  int32       `json:"offset_value"`
	LimitValue   int32       `json:"limit_value"`
}

type ListProductsPublicRow struct {
	ID         pgtype.UUID        `json:"id"`
	Title      string             `json:"title"`
	Slug       string             `json:"slug"`
	Price      int64              `json:"price"`
	CompareAt  pgtype.Int8        `json:"compare_at"`
	InStock    bool               `json:"in_stock"`
	Thumbnail  pgtype.Text        `json:"thumbnail"`
	Badges     []string           `json:"badges"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	TotalStock int32              `json:"total_stock"`
}

func (q *Queries) ListProductsPublic(ctx context.Context, arg ListProductsPublicParams) ([]ListProductsPublicRow, error) {
	rows, err := q.db.Query(ctx, listProductsPublic,
		arg.Q,
		arg.CategorySlug,
		arg.BrandSlug,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStock,
		arg.Sort,
		arg.OffsetValue,
		arg.LimitValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsPublicRow
	for rows.Next() {
		var i ListProductsPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Price,
			&i.CompareAt,
			&i.InStock,
			&i.Thumbnail,
			&i.Badges,
			&i.CreatedAt,
			&i.TotalStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelatedByCategory = `-- name: ListRelatedByCategory :many
SELECT p.id,
       p.title,
       p.slug,
       p.price,
       p.compare_at,
       p.in_stock,
       p.thumbnail,
       p.badges,
       p.created_at
FROM products p
WHERE p.category_id = $1
  AND p.slug <> $2
ORDER BY p.created_at DESC
LIMIT 8
`

type ListRelatedByCategoryParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	Slug       string      `json:"slug"`
}

type ListRelatedByCategoryRow struct {
	ID        pgtype.UUID        `json:"id"`
	Title     string             `json:"title"`
	Slug      string             `json:"slug"`
	Price     int64              `json:"price"`
	CompareAt pgtype.Int8        `json:"compare_at"`
	InStock   bool               `json:"in_stock"`
	Thumbnail pgtype.Text        `json:"thumbnail"`
	Badges    []string           `json:"badges"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListRelatedByCategory(ctx context.Context, arg ListRelatedByCategoryParams) ([]ListRelatedByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listRelatedByCategory, arg.CategoryID, arg.Slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRelatedByCategoryRow
	for rows.Next() {
		var i ListRelatedByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Price,
			&i.CompareAt,
			&i.InStock,
			&i.Thumbnail,
			&i.Badges,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpecsByProduct = `-- name: ListSpecsByProduct :many
SELECT id,
       product_id,
       key,
       value
FROM product_specs
WHERE product_id = $1
ORDER BY key ASC, id
`

func (q *Queries) ListSpecsByProduct(ctx context.Context, productID pgtype.UUID) ([]ProductSpec, error) {
	rows, err := q.db.Query(ctx, listSpecsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductSpec
	for rows.Next() {
		var i ProductSpec
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Key,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariantsByProduct = `-- name: ListVariantsByProduct :many
SELECT id,
       product_id,
       sku,
       price,
       stock,
       attributes
FROM product_variants
WHERE product_id = $1
ORDER BY sku NULLS LAST, id
`

func (q *Queries) ListVariantsByProduct(ctx context.Context, productID pgtype.UUID) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, listVariantsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.Stock,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
