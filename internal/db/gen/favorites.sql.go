// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: favorites.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFavorite = `-- name: AddFavorite :exec
INSERT INTO favorites (user_id, product_id, tenant_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, product_id) DO NOTHING
`

type AddFavoriteParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	ProductID pgtype.UUID `json:"product_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) AddFavorite(ctx context.Context, arg AddFavoriteParams) error {
	_, err := q.db.Exec(ctx, addFavorite, arg.UserID, arg.ProductID, arg.TenantID)
	return err
}

const checkFavorite = `-- name: CheckFavorite :one
SELECT 1 
FROM favorites 
WHERE user_id = $1 AND product_id = $2 AND tenant_id = $3
LIMIT 1
`

type CheckFavoriteParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	ProductID pgtype.UUID `json:"product_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CheckFavorite(ctx context.Context, arg CheckFavoriteParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkFavorite, arg.UserID, arg.ProductID, arg.TenantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listFavorites = `-- name: ListFavorites :many
SELECT f.product_id, f.created_at, p.title as product_name, p.slug as product_slug, p.price, p.thumbnail as image_url
FROM favorites f
JOIN products p ON f.product_id = p.id
WHERE f.user_id = $1 AND f.tenant_id = $2
ORDER BY f.created_at DESC
`

type ListFavoritesParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type ListFavoritesRow struct {
	ProductID   pgtype.UUID        `json:"product_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	ProductName string             `json:"product_name"`
	ProductSlug string             `json:"product_slug"`
	Price       int64              `json:"price"`
	ImageUrl    pgtype.Text        `json:"image_url"`
}

func (q *Queries) ListFavorites(ctx context.Context, arg ListFavoritesParams) ([]ListFavoritesRow, error) {
	rows, err := q.db.Query(ctx, listFavorites, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesRow
	for rows.Next() {
		var i ListFavoritesRow
		if err := rows.Scan(
			&i.ProductID,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductSlug,
			&i.Price,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM favorites
WHERE user_id = $1 AND product_id = $2 AND tenant_id = $3
`

type RemoveFavoriteParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	ProductID pgtype.UUID `json:"product_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeFavorite, arg.UserID, arg.ProductID, arg.TenantID)
	return err
}
